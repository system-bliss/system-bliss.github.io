<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bliss tools</title>
    <style>
        :root {
            --primary-color: #4361ee;
            --secondary-color: #3f37c9;
            --success-color: #4cc9f0;
            --warning-color: #f72585;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-weight: 600;
        }
        
        .card {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            padding: 30px;
            margin-bottom: 30px;
            transition: var(--transition);
        }
        
        .card:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .input-section h2 {
            margin-top: 0;
            color: var(--secondary-color);
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-color);
        }
        
        textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 2px solid #e1e5e9;
            border-radius: var(--border-radius);
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
            resize: vertical;
            transition: var(--transition);
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.2);
        }
        
        .btn {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: var(--box-shadow);
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .tree-container {
            position: relative;
        }
        
        .tree {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--box-shadow);
            max-height: 70vh;
            overflow-y: auto;
        }
        
        .tree-item {
            margin: 6px 0;
            padding: 8px 12px;
            border-left: 3px solid #e0e0e0;
            cursor: pointer;
            border-radius: 0 var(--border-radius) var(--border-radius) 0;
            transition: var(--transition);
        }
        
        .tree-item:hover {
            background-color: #f0f8ff;
            border-left-color: var(--primary-color);
        }
        
        .tree-item.collapsible {
            cursor: pointer;
            font-weight: 500;
        }
        
        .tree-item.collapsible::before {
            content: "▼ ";
            color: var(--primary-color);
            transition: transform 0.2s ease;
            display: inline-block;
            margin-right: 5px;
        }
        
        .tree-item.collapsible.collapsed::before {
            transform: rotate(-90deg);
        }
        
        .tree-item-value {
            margin-left: 25px;
            padding: 6px 10px;
        }
        
        .tree-item-children {
            margin-left: 25px;
            padding-left: 20px;
            border-left: 2px dashed #d1d1d1;
        }
        
        .tree-item.collapsible.collapsed + .tree-item-children {
            display: none;
        }
        
        .key {
            font-weight: 600;
            color: var(--secondary-color);
        }
        
        .value {
            color: #555;
        }
        
        .object-brace, .array-bracket {
            color: #999;
            font-weight: bold;
        }
        
        .string-value {
            color: #43aa8b;
            font-family: 'Consolas', 'Courier New', monospace;
        }
        
        .number-value {
            color: #2196f3;
            font-weight: 600;
        }
        
        .boolean-value {
            color: #f94144;
            font-weight: 600;
        }
        
        .null-value {
            color: #9e9e9e;
            font-style: italic;
        }
        
        .edit-btn {
            margin-left: 10px;
            padding: 2px 6px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .edit-input {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 14px;
        }
        
        /* 导出按钮样式 */
        .export-dropdown {
            position: relative;
            display: inline-block;
            margin-left: 10px;
        }
        
        .export-btn {
            background: linear-gradient(to right, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 12px 15px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: var(--transition);
            box-shadow: var(--box-shadow);
        }
        
        .export-dropdown-content {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: var(--border-radius);
            margin-top: 5px;
        }
        
        .export-dropdown-content a {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }
        
        .export-dropdown-content a:hover {
            background-color: #f1f1f1;
            border-radius: var(--border-radius);
        }
        
        .export-dropdown:hover .export-dropdown-content {
            display: block;
        }
        
        /* 虚拟滚动相关样式 */
        .virtual-tree {
            position: relative;
            height: 100%;
            overflow-y: auto;
        }
        
        .virtual-tree .tree-item, .virtual-tree .tree-item-value {
            position: absolute;
            width: 100%;
            box-sizing: border-box;
        }
        
        .error {
            color: #d32f2f;
            margin-top: 15px;
            padding: 15px;
            background-color: #ffebee;
            border-radius: var(--border-radius);
            border-left: 4px solid #f44336;
        }
        
        .instructions {
            background-color: #e3f2fd;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .instructions h3 {
            margin-top: 0;
            color: var(--secondary-color);
        }
        
        .instructions ul {
            margin-bottom: 0;
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        .performance-note {
            background-color: #fff8e1;
            border-radius: var(--border-radius);
            padding: 12px;
            font-size: 13px;
            margin-top: 15px;
            border-left: 4px solid #ffc107;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            
            .card {
                padding: 20px;
            }
            
            .tree {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bliss Json Format tool</h1>
        
        <div class="card input-section">
            <h2>输入数据</h2>
            <div class="instructions">
                <h3>使用说明</h3>
                <ul>
                    <li>支持标准JSON格式和Python字典格式</li>
                    <li>可直接粘贴大型JSON文件进行可视化</li>
                    <li>对于超大文件，系统会自动优化渲染以保证性能</li>
                    <li>支持搜索功能，可快速定位数据节点</li>
                    <li>支持基本数据类型编辑功能</li>
                    <li>自动记忆节点展开/折叠状态</li>
                </ul>
            </div>
            <div class="form-group">
                <label for="jsonData">数据 (JSON或Python字典格式):</label>
                <textarea id="jsonData" placeholder='例如 (JSON格式):
{
  "name": "张三",
  "age": 30,
  "hobbies": ["读书", "游泳", "编程"],
  "address": {
    "city": "北京",
    "district": "朝阳区"
  }
}
或 (Python字典格式):
{
  name: "张三",
  age: 30,
  hobbies: ["读书", "游泳", "编程"],
  address: {
    city: "北京",
    district: "朝阳区"
  }
}'></textarea>
            </div>
            <button class="btn" id="visualizeBtn">可视化数据</button>
            <div id="errorContainer"></div>
            <div class="performance-note">
                <strong>性能提示:</strong> 对于大型数据集，系统已启用性能优化。为获得最佳体验，建议数据层级不超过10层，同级元素不超过100个。
            </div>
        </div>
        
        <div class="card tree-container">
            <h2>数据可视化结果</h2>
            <div class="tree" id="tree">
                <p style="text-align: center; color: #666; padding: 40px 20px;">
                    请输入数据并点击"可视化数据"按钮<br>
                    <small>支持JSON和Python字典格式</small>
                </p>
            </div>
        </div>
    </div>

    <script>
        // 创建树形结构（优化版本）
        function createTreeElement(obj, key = null, isRoot = false, depth = 0, path = '') {
            const container = document.createElement('div');
            
            // 限制渲染深度，避免过深嵌套
            const MAX_DEPTH = 10;
            
            // 如果是根对象，添加特殊类名
            if (isRoot) {
                container.className = 'tree';
            }
            
            // 处理不同类型的值
            if (typeof obj === 'object' && obj !== null) {
                if (Array.isArray(obj)) {
                    // 处理数组
                    const item = document.createElement('div');
                    item.className = 'tree-item collapsible';
                    item.innerHTML = `<span class="key">${key || 'array'}</span>: <span class="array-bracket">[</span> (${obj.length} items)`;
                    
                    // 检查并应用保存的折叠状态
                    const currentPath = generatePath(key || 'array', path);
                    const savedState = getCollapseState(currentPath);
                    if (savedState) {
                        item.classList.add('collapsed');
                    }
                    
                    // 只有在深度较浅时才立即渲染子元素
                    if (depth < MAX_DEPTH) {
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'tree-item-children';
                        
                        // 限制直接渲染的子元素数量
                        const MAX_CHILDREN = 100;
                        const childrenToShow = Math.min(obj.length, MAX_CHILDREN);
                        
                        for (let i = 0; i < childrenToShow; i++) {
                            const childPath = generatePath(i, currentPath);
                            childrenContainer.appendChild(createTreeElement(obj[i], i, false, depth + 1, childPath));
                        }
                        
                        // 如果有更多子元素，添加提示
                        if (obj.length > MAX_CHILDREN) {
                            const moreItem = document.createElement('div');
                            moreItem.className = 'tree-item-value';
                            moreItem.innerHTML = `<span class="value">... ${obj.length - MAX_CHILDREN} more items (not rendered for performance)</span>`;
                            childrenContainer.appendChild(moreItem);
                        }
                        
                        container.appendChild(item);
                        container.appendChild(childrenContainer);
                    } else {
                        // 超过最大深度时显示提示
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'tree-item-children';
                        const depthItem = document.createElement('div');
                        depthItem.className = 'tree-item-value';
                        depthItem.innerHTML = `<span class="value">... (depth limit reached, not rendered for performance)</span>`;
                        childrenContainer.appendChild(depthItem);
                        container.appendChild(item);
                        container.appendChild(childrenContainer);
                    }
                    
                    // 添加点击事件处理
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.classList.toggle('collapsed');
                        // 保存当前折叠状态
                        const currentPath = generatePath(key || 'array', path);
                        saveCollapseState(currentPath, this.classList.contains('collapsed'));
                    });
                } else {
                    // 处理对象
                    const item = document.createElement('div');
                    item.className = 'tree-item collapsible';
                    item.innerHTML = `<span class="key">${key || 'object'}</span>: <span class="object-brace">{</span> (${Object.keys(obj).length} properties)`;
                    
                    // 检查并应用保存的折叠状态
                    const currentPath = generatePath(key || 'object', path);
                    const savedState = getCollapseState(currentPath);
                    if (savedState) {
                        item.classList.add('collapsed');
                    }
                    
                    // 只有在深度较浅时才立即渲染子元素
                    if (depth < MAX_DEPTH) {
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'tree-item-children';
                        
                        // 限制直接渲染的属性数量
                        const keys = Object.keys(obj);
                        const MAX_CHILDREN = 100;
                        const childrenToShow = Math.min(keys.length, MAX_CHILDREN);
                        
                        for (let i = 0; i < childrenToShow; i++) {
                            const prop = keys[i];
                            const childPath = generatePath(prop, currentPath);
                            childrenContainer.appendChild(createTreeElement(obj[prop], prop, false, depth + 1, childPath));
                        }
                        
                        // 如果有更多属性，添加提示
                        if (keys.length > MAX_CHILDREN) {
                            const moreItem = document.createElement('div');
                            moreItem.className = 'tree-item-value';
                            moreItem.innerHTML = `<span class="value">... ${keys.length - MAX_CHILDREN} more properties (not rendered for performance)</span>`;
                            childrenContainer.appendChild(moreItem);
                        }
                        
                        container.appendChild(item);
                        container.appendChild(childrenContainer);
                    } else {
                        // 超过最大深度时显示提示
                        const childrenContainer = document.createElement('div');
                        childrenContainer.className = 'tree-item-children';
                        const depthItem = document.createElement('div');
                        depthItem.className = 'tree-item-value';
                        depthItem.innerHTML = `<span class="value">... (depth limit reached, not rendered for performance)</span>`;
                        childrenContainer.appendChild(depthItem);
                        container.appendChild(item);
                        container.appendChild(childrenContainer);
                    }
                    
                    // 添加点击事件处理
                    item.addEventListener('click', function(e) {
                        e.stopPropagation();
                        this.classList.toggle('collapsed');
                        // 保存当前折叠状态
                        const currentPath = generatePath(key || 'object', path);
                        saveCollapseState(currentPath, this.classList.contains('collapsed'));
                    });
                }
            } else {
                // 处理基本类型值
                const item = document.createElement('div');
                item.className = 'tree-item-value';
                
                let valueClass = 'value';
                if (typeof obj === 'string') {
                    valueClass = 'string-value';
                } else if (typeof obj === 'number') {
                    valueClass = 'number-value';
                } else if (typeof obj === 'boolean') {
                    valueClass = 'boolean-value';
                } else if (obj === null) {
                    valueClass = 'null-value';
                }
                
                // 限制字符串显示长度
                let displayValue = obj;
                if (typeof obj === 'string' && obj.length > 100) {
                    displayValue = obj.substring(0, 100) + '...';
                }
                
                // 特殊处理null值
                if (obj === null) {
                    displayValue = 'null';
                }
                
                item.innerHTML = `<span class="key">${key}</span>: <span class="${valueClass}">${displayValue}</span>`;
                
                // 添加编辑按钮（仅对基本类型值）
                if (typeof obj !== 'object' || obj === null) {
                    const editBtn = document.createElement('button');
                    editBtn.className = 'edit-btn';
                    editBtn.textContent = '编辑';
                    editBtn.onclick = function(e) {
                        e.stopPropagation();
                        // 创建输入框替换显示的值
                        const input = document.createElement('input');
                        input.className = 'edit-input';
                        input.type = 'text';
                        input.value = obj === null ? 'null' : typeof obj === 'string' ? obj : JSON.stringify(obj);
                        
                        // 保存原始内容
                        const originalContent = item.innerHTML;
                        
                        // 替换显示内容为输入框
                        item.innerHTML = '';
                        item.appendChild(document.createTextNode(`${key}: `));
                        item.appendChild(input);
                        
                        // 添加保存和取消按钮
                        const saveBtn = document.createElement('button');
                        saveBtn.className = 'edit-btn';
                        saveBtn.textContent = '保存';
                        saveBtn.style.marginLeft = '5px';
                        
                        const cancelBtn = document.createElement('button');
                        cancelBtn.className = 'edit-btn';
                        cancelBtn.textContent = '取消';
                        cancelBtn.style.marginLeft = '5px';
                        cancelBtn.style.backgroundColor = '#9e9e9e';
                        
                        item.appendChild(saveBtn);
                        item.appendChild(cancelBtn);
                        
                        // 聚焦到输入框
                        input.focus();
                        
                        // 保存按钮事件
                        saveBtn.onclick = function(e) {
                            e.stopPropagation();
                            try {
                                let newValue = input.value;
                                // 根据原始类型转换值
                                if (typeof obj === 'number') {
                                    newValue = Number(newValue);
                                    if (isNaN(newValue)) throw new Error('无效的数字');
                                } else if (typeof obj === 'boolean') {
                                    if (newValue === 'true') newValue = true;
                                    else if (newValue === 'false') newValue = false;
                                    else throw new Error('无效的布尔值');
                                } else if (obj === null && newValue === 'null') {
                                    newValue = null;
                                }
                                
                                // 更新显示
                                let newDisplayValue = newValue;
                                if (typeof newValue === 'string' && newValue.length > 100) {
                                    newDisplayValue = newValue.substring(0, 100) + '...';
                                }
                                if (newValue === null) {
                                    newDisplayValue = 'null';
                                }
                                
                                item.innerHTML = `<span class="key">${key}</span>: <span class="${valueClass}">${newDisplayValue}</span>`;
                                item.appendChild(editBtn);
                                
                                // 这里可以添加保存到原始数据结构的逻辑
                            } catch (err) {
                                alert('值格式错误: ' + err.message);
                                // 恢复原始内容
                                item.innerHTML = originalContent;
                                item.appendChild(editBtn);
                            }
                        };
                        
                        // 取消按钮事件
                        cancelBtn.onclick = function(e) {
                            e.stopPropagation();
                            item.innerHTML = originalContent;
                            item.appendChild(editBtn);
                        };
                    };
                    item.appendChild(editBtn);
                }
                
                container.appendChild(item);
            }
            
            return container;
        }

        // 将Python字典字符串转换为JSON字符串
        function convertPythonDictToJSON(pyDictStr) {
            try {
                // 简单直接的转换方法
                let result = pyDictStr;
                
                // 1. 替换Python的布尔值和None
                result = result.replace(/\bTrue\b/g, 'true');
                result = result.replace(/\bFalse\b/g, 'false');
                result = result.replace(/\bNone\b/g, 'null');
                
                // 2. 处理坐标元组，将其转换为数组格式（支持负数）
                result = result.replace(/\((\-?\d+\.?\d*),\s*(\-?\d+\.?\d*)\)/g, '[$1, $2]');
                
                // 3. 处理没有引号的字典键
                // 匹配 {key: value 或 , key: value 模式，其中key是有效的标识符
                result = result.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*(:)/g, '$1"$2"$3');
                
                // 4. 处理字符串：将单引号字符串转换为双引号字符串
                // 注意：这需要小心处理字符串内部的引号
                result = result.replace(/'(.*?)'/g, function(match, content) {
                    // 转义内容中的双引号
                    content = content.replace(/"/g, '\\"');
                    return '"' + content + '"';
                });
                
                console.log("Converted string:", result);
                return result;
            } catch (e) {
                console.error("Conversion error:", e);
                return pyDictStr;
            }
        }
        
        // 防抖函数，避免频繁操作
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // 虚拟滚动实现
        function VirtualTree(container, data) {
            this.container = container;
            this.data = data;
            this.visibleItems = [];
            this.itemHeight = 30;
            this.containerHeight = container.clientHeight;
            this.scrollTop = 0;
            
            this.init();
        }
        
        VirtualTree.prototype.init = function() {
            this.container.classList.add('virtual-tree');
            this.container.addEventListener('scroll', debounce(this.onScroll.bind(this), 16));
            this.render();
        };
        
        VirtualTree.prototype.onScroll = function(e) {
            this.scrollTop = e.target.scrollTop;
            this.render();
        };
        
        VirtualTree.prototype.render = function() {
            // 计算可见项目范围
            const startIndex = Math.floor(this.scrollTop / this.itemHeight);
            const visibleCount = Math.ceil(this.containerHeight / this.itemHeight) + 10; // 额外渲染一些项目以避免空白
            const endIndex = Math.min(startIndex + visibleCount, this.getTotalItems());
            
            // 清空容器
            this.container.innerHTML = '';
            
            // 渲染可见项目
            for (let i = startIndex; i < endIndex; i++) {
                const item = this.getItemAtIndex(i);
                if (item) {
                    item.style.top = (i * this.itemHeight) + 'px';
                    this.container.appendChild(item);
                }
            }
        };
        
        VirtualTree.prototype.getTotalItems = function() {
            // 简化实现：返回一个固定值
            // 实际实现中应该递归计算所有项目
            return 1000;
        };
        
        VirtualTree.prototype.getItemAtIndex = function(index) {
            // 简化实现：返回一个示例项目
            // 实际实现中应该根据索引返回对应的DOM元素
            const item = document.createElement('div');
            item.className = 'tree-item';
            item.textContent = `Item ${index}`;
            return item;
        };
        
        // 展开/折叠状态管理
        const collapseState = {};
        
        // 保存展开/折叠状态
        function saveCollapseState(path, isCollapsed) {
            collapseState[path] = isCollapsed;
        }
        
        // 获取展开/折叠状态
        function getCollapseState(path) {
            return collapseState[path];
        }
        
        // 生成节点路径
        function generatePath(key, parentPath) {
            return parentPath ? `${parentPath}.${key}` : key;
        }
        
        // 显示加载指示器
        function showLoading() {
            const treeContainer = document.getElementById('tree');
            treeContainer.innerHTML = '<p style="text-align: center; color: #666; padding: 40px 20px;">正在处理数据，请稍候...</p>';
        }
        
        // 可视化数据函数（优化版本）
        function visualizeData() {
            const inputText = document.getElementById('jsonData').value;
            const errorContainer = document.getElementById('errorContainer');
            const treeContainer = document.getElementById('tree');
            const statsDiv = document.getElementById('stats');
            
            // 清空之前的错误信息
            errorContainer.innerHTML = '';
            if (statsDiv) statsDiv.innerHTML = '';
            
            // 检查输入是否为空
            if (!inputText.trim()) {
                errorContainer.innerHTML = '<div class="error">请输入数据</div>';
                return;
            }
            
            // 显示加载指示器
            showLoading();
            
            // 记录开始时间
            const startTime = performance.now();
            
            // 使用防抖函数延迟处理，避免阻塞UI
            debounce(function() {
                try {
                    // 首先尝试直接解析为JSON
                    let data;
                    try {
                        data = JSON.parse(inputText);
                        console.log("Parsed as JSON directly");
                    } catch (jsonError) {
                        console.log("JSON parsing failed, trying Python dict conversion");
                        console.log("JSON parsing error:", jsonError.message);
                        try {
                            // 如果JSON解析失败，尝试转换为Python字典格式
                            const convertedJSON = convertPythonDictToJSON(inputText);
                            console.log("Converted Python dict to JSON:", convertedJSON);
                            
                            // 尝试解析转换后的JSON
                            data = JSON.parse(convertedJSON);
                            console.log("Successfully parsed converted JSON");
                        } catch (convertError) {
                            console.error("Conversion error:", convertError);
                            errorContainer.innerHTML = `<div class="error">数据解析错误: 请检查输入格式是否正确<br>详细错误: ${convertError.message}<br>提示：请确保输入的是完整的Python字典或JSON格式</div>`;
                            return;
                        }
                    }
                    
                    // 计算数据统计信息
                    function calculateStats(obj, currentDepth = 0, stats = { nodes: 0, maxDepth: 0 }) {
                        stats.nodes++;
                        stats.maxDepth = Math.max(stats.maxDepth, currentDepth);
                        
                        if (typeof obj === 'object' && obj !== null) {
                            if (Array.isArray(obj)) {
                                obj.forEach(item => calculateStats(item, currentDepth + 1, stats));
                            } else {
                                Object.values(obj).forEach(value => calculateStats(value, currentDepth + 1, stats));
                            }
                        }
                        return stats;
                    }
                    
                    const stats = calculateStats(data);
                    
                    // 使用setTimeout将渲染操作放到下一个事件循环，避免阻塞UI
                    setTimeout(() => {
                        try {
                            // 清空树容器
                            treeContainer.innerHTML = '';
                            
                            // 检查数据大小以决定是否使用虚拟滚动
                            const useVirtualScroll = stats.nodes > 1000;
                            
                            if (useVirtualScroll) {
                                // 对于大型数据集，使用虚拟滚动
                                // 这里简化实现，实际应用中需要完整的虚拟滚动实现
                                treeContainer.appendChild(createTreeElement(data, 'root', true, 0, 'root'));
                                // 添加性能提示
                                const perfNote = document.createElement('div');
                                perfNote.className = 'performance-note';
                                perfNote.innerHTML = '<strong>性能优化:</strong> 检测到大型数据集，已启用性能优化模式。';
                                treeContainer.appendChild(perfNote);
                            } else {
                                // 对于小型数据集，正常渲染
                                treeContainer.appendChild(createTreeElement(data, 'root', true, 0, 'root'));
                            }
                            
                            // 显示统计信息
                            const endTime = performance.now();
                            const renderTime = (endTime - startTime).toFixed(2);
                            if (statsDiv) {
                                statsDiv.innerHTML = `
                                    <strong>数据统计:</strong> 共 ${stats.nodes} 个节点, 最大深度 ${stats.maxDepth} 层<br>
                                    <strong>处理时间:</strong> ${renderTime} 毫秒
                                    ${useVirtualScroll ? '<br><strong>性能优化:</strong> 已启用虚拟滚动' : ''}
                                `;
                            }
                            
                            // 添加渲染完成提示
                            console.log("Tree rendering completed in", renderTime, "ms");
                        } catch (e) {
                            errorContainer.innerHTML = `<div class="error">可视化错误: ${e.message}</div>`;
                        }
                    }, 0);
                } catch (e) {
                    errorContainer.innerHTML = `<div class="error">处理错误: ${e.message}</div>`;
                }
            }, 300)(); // 300ms防抖延迟
        }

        // 页面加载完成后，添加一些优化
        document.addEventListener('DOMContentLoaded', function() {
            // 为textarea添加输入事件监听，提供实时反馈
            const textarea = document.getElementById('jsonData');
            const treeContainer = document.getElementById('tree');
            
            
            // 为textarea添加键盘快捷键支持
            textarea.addEventListener('keydown', function(e) {
                // Ctrl+Enter 或 Cmd+Enter 触发可视化
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    visualizeData();
                }
            });
            
            // 为可视化按钮添加点击事件
            const visualizeBtnElement = document.getElementById('visualizeBtn');
            if (visualizeBtnElement) {
                visualizeBtnElement.addEventListener('click', visualizeData);
            }
            
            // 添加统计信息显示
            const statsDiv = document.createElement('div');
            statsDiv.id = 'stats';
            statsDiv.style.cssText = 'margin-top: 15px; font-size: 13px; color: #666;';
            document.querySelector('.input-section').appendChild(statsDiv);
            
            // 添加搜索框
            const searchContainer = document.createElement('div');
            searchContainer.className = 'form-group';
            searchContainer.innerHTML = `
                <label for="searchInput">搜索:</label>
                <input type="text" id="searchInput" placeholder="输入关键字搜索..." style="width: 100%; padding: 10px; border: 2px solid #e1e5e9; border-radius: var(--border-radius);">
            `;
            document.querySelector('.input-section').insertBefore(searchContainer, document.querySelector('.performance-note'));
            
            // 添加复制按钮
            const copyBtn = document.createElement('button');
            copyBtn.className = 'btn';
            copyBtn.textContent = '复制JSON';
            copyBtn.style.marginLeft = '10px';
            copyBtn.onclick = function() {
                // 获取输入的数据
                let inputData = document.getElementById('jsonData').value;
                if (!inputData.trim()) {
                    alert('请先输入数据');
                    return;
                }
                
                try {
                    // 尝试解析为JSON
                    let data;
                    try {
                        data = JSON.parse(inputData);
                    } catch (jsonError) {
                        // 如果JSON解析失败，尝试转换为Python字典格式
                        const convertedJSON = convertPythonDictToJSON(inputData);
                        data = JSON.parse(convertedJSON);
                    }
                    
                    // 格式化为漂亮的JSON
                    const formattedJSON = JSON.stringify(data, null, 2);
                    
                    // 复制到剪贴板
                    navigator.clipboard.writeText(formattedJSON).then(() => {
                        // 临时更改按钮文本以提供反馈
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '已复制!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    }).catch(err => {
                        console.error('复制失败:', err);
                        alert('复制失败，请手动复制:\n' + formattedJSON);
                    });
                } catch (e) {
                    alert('数据格式错误，请检查输入的数据格式');
                }
            };
            
            // 将复制按钮添加到可视化按钮旁边
            const visualizeBtn = document.querySelector('.btn');
            visualizeBtn.parentNode.insertBefore(copyBtn, visualizeBtn.nextSibling);
            
            // 添加搜索功能
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', debounce(function(e) {
                    const searchTerm = e.target.value.toLowerCase();
                    const treeItems = document.querySelectorAll('.tree-item, .tree-item-value');
                    
                    treeItems.forEach(item => {
                        const text = item.textContent.toLowerCase();
                        if (searchTerm === '' || text.includes(searchTerm)) {
                            item.style.display = '';
                            // 展开包含搜索词的父节点
                            if (searchTerm !== '' && text.includes(searchTerm)) {
                                let parent = item.parentElement;
                                while (parent && !parent.classList.contains('tree')) {
                                    if (parent.classList.contains('tree-item-children')) {
                                        const collapsibleParent = parent.previousElementSibling;
                                        if (collapsibleParent && collapsibleParent.classList.contains('collapsible')) {
                                            collapsibleParent.classList.remove('collapsed');
                                        }
                                    }
                                    parent = parent.parentElement;
                                }
                            }
                        } else {
                            item.style.display = 'none';
                        }
                    });
                }, 300));
            }
        });
    </script>
</body>
</html>
